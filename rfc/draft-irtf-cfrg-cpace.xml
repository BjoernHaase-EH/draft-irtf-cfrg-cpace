<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2104 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4493 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4493.xml">
<!ENTITY RFC5480 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5480.xml">
<!ENTITY RFC5869 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5869.xml">
<!ENTITY RFC6234 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6234.xml">
<!ENTITY RFC7748 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7748.xml">
<!ENTITY RFC7914 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7914.xml">
<!ENTITY RFC8032 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8032.xml">
<!ENTITY RFC8174 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8174.xml">
<!ENTITY RFC8265 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8265.xml">
<!ENTITY uks SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-mmusic-sdp-uks">
]>
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>
<rfc category="info" ipr="trust200902" docName="draft-irtf-cfrg-cpace-02" submissionType="IETF">
  <front>
    <title>CPace, a balanced composable PAKE</title>
    <author fullname="Michel Abdalla" initials="M." surname="Abdalla">
      <organization>DI, École Normale Supérieure, Paris</organization>
      <address>
<!--         45, Rue d'Ulm, 75230 Paris, Cedex 05 -->
        <email>michel.abdalla@ens.fr </email>
      </address>
    </author>
    <author fullname="Bjoern Haase" initials="B." surname="Haase">
      <organization>Endress + Hauser Liquid Analysis</organization>
      <address>
<!--         Dieselstrasse 24, 70839 Gerlingen, Germany -->
        <email>bjoern.m.haase@web.de</email>
      </address>
    </author>

    <author fullname="Julia Hesse" initials="J." surname="Hesse">
      <organization>IBM, Zürich Research Laboratory</organization>
      <address>
<!--         Säumerstrasse 4, CH-8803 Rüschlikon, Switzerland -->
        <email>JHS@zurich.ibm.com </email>
      </address>
    </author>
    
    <date month="July" year="2021"/>
    <abstract>
      <t>This document describes CPace which is a protocol for two
      parties that share a low-entropy secret (password) to derive a strong shared key without 
      disclosing the secret to offline dictionary attacks. This method was tailored for constrained devices,
      is compatible with any group of both prime- and non-prime order,
       and comes with  a security proof providing composability guarantees.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" title="Introduction">
      <t>This document describes CPace which is a protocol for two
      parties that share a low-entropy secret (password) to derive a to derive a strong shared key without 
      disclosing the secret to offline dictionary attacks. 
           
      The CPace method was tailored for constrained devices and
      specifically considers efficiency and hardware side-channel attack mitigations at the protocol level.
      CPace is designed to be compatible with any group of both prime- and non-prime order and explicitly
      handles the complexity of cofactor clearing on the protcol level. CPace
      comes with game-based and simulation based proofs where the latter provides composability guarantees. 
      As a protocol, CPace is designed
      to be compatible with so-called "x-coordinate-only" Diffie-Hellman implementations on elliptic curve
      groups.</t>
    <t> CPace is designed to be suitable as both, a building block within a larger protocol construction using CPace as substep, 
        and as a standalone protocol. </t>
    <t> It is considered, that for composed larger protocol constructions, the CPace subprotocol might be best executed in a 
        separate cryptographic hardware, such as secure element chipsets. The CPace protocol design aims at considering 
        the resulting constraints. </t>

    </section>
    <section anchor="notation" title="Requirements Notation">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be interpreted as
        described in BCP 14 <xref target="RFC2119" /> <xref target="RFC8174" />
        when, and only when, they
        appear in all capitals, as shown here.</t>
    </section>
    <section anchor="definition" title="Definition  CPace ">
      <section title="Setup" anchor="setup">
        <t>
        For CPace both communication partners need to agree on a common cipher suite which consists of choosing a common
        hash function H and an elliptic curve group G.
        </t>

        <t> With H we denote a hash primitive with a hash function H.hash(m,l) 
            that operates on an input octet string m and returns a hash result containing the first l result octets
            calculated by the primitive.
        </t>
        <t>
            A given hash function H is characterized by its input and its preferred output sizes. 
            We use an object-style notation 
            H.constant_name. With H.b_in_bytes we denote the preferred output size in bytes of the primitive such
            that the hash function returns the full length of the hash if the second length parameter is not
            given: H.hash(m) = H.hash(m, H.b_in_bytes).
        </t>
        <t>
            With H.bmax_in_bytes we denote the maximum output size in octets supported by the hash primitive.
        </t>
        <t>
            A first common choice for H is SHA512 <xref target="RFC6234"/> where b_in_bytes = bmax_in_bytes = 64
            as a fixed-length output of 64 bytes is produced.
            Another suitable choice for H is SHAKE256 <xref target="SHA3"/> which is also designed for a preferred length 
            and security parameter of b_in_bytes = 64 but which allows for variable-length outputs without 
            a fixed limit bmax_in_bytes.
        </t>
        <t>
            With H.s_in_bytes we denote the input block size used by H. 
            For SHA512, e.g. the input block size s_in_bytes is 128, while for SHAKE256 the 
            input block size amounts to 136 bytes.           
        </t>
        <t>
        For a given group G this document specifies how to define the following set of group-specific 
        functions and constants for the protocol execution. For making the implicit dependence of the respective
        functions and constants on the group G transparent, we use a object-style notation 
        G.function_name() and G.constant_name .
        </t>

        <t>
        With G.I we denote a unique octet string representation of the neutral element of group G.
        </t>

        <t>g = G.calculate_generator(H, PRS,CI,sid). With calculate_generator we denote a function that outputs a
        octet string representation of a group element in G which is derived from input octet strings PRS, CI, sid using
        a hash function primitive.
        </t>

        <t>y = G.sample_scalar(). This function returns an octet string representation of a scalar value appropriate as a
        private Diffie-Hellman key for group G.
        </t>
    
        <t>Y = G.scalar_mult(y,g). This function takes a generator g as first parameter and a scalar y as second 
        parameter and returns an octet string representation of a group element Y.
        </t>
        
        <t>K = G.scalar_mult_vfy(y,X). This function returns an octet string representation of a group element K which is
        calculated from a scalar y and a group element X. Moreover scalar_mult_vfy implements validity verifications of the inputs
        and returns the neutral element G.I if the validity check fails.        
        </t>

       </section>

      <section title="Inputs" anchor="inputs">
       <t> With PRS we denote a password-related octet string which is a MANDATORY input for all CPace instantiations. 
           Typically PRS is derived from a low-entropy secret such as a user-supplied password (pw) or a personal 
           identification number.
       </t>

       <t> With CI we denote an OPTIONAL octet string for the channel identifier. CI can be used for
        binding CPace to one specific communication channel, if a common octet string representation for CI is 
        available for both protocol partners upon protocol start.
       </t>

       <t> With sid we denote an OPTIONAL octet string input containing a session id. In application scenarios 
       where a higher-level protocol has established a unique sid this parameter can be used to bind the CPace protocol execution
       to one specific session.
       </t>

       <t> With ADa and ADb we denote OPTIONAL octet strings of parties A and B that contain associated public data 
       of the communication partners.
       ADa could for instance include party identifiers.
       </t>
 
       </section>

      <section title="Notation" anchor="protocolSpecificNotation">      
        <t> With str1 || str2 we denote concatenation of octet strings. </t>

        <t> With oCAT(str1,str2) we denote ordered concatenation of octet strings such that oCAT(str1,str2) = str1 || str2 
        if str2 > str1 and oCAT(str1,str2) = str2 || str1 otherwise. </t> 
       
        <t> CONCAT(str1,str2) defines a concatenation function that depends on the application scenario. 
        In applications where CPace is used without clear initiator and responder roles, i.e. where the ordering of 
        messages is not enforced by the protocol flow ordered concatenation SHALL BE used, 
        i.e. CONCAT(str1,str2) == oCAT(str1,str2). 
        
        In settings with defined initiator and responder roles
        CONCAT(str1,str2) SHALL BE defined as unordered concatenation: CONCAT(str1,str2) == str1 || str2. </t>
        
        <t> With len(S) we denote the number of octets in a string S. </t>
        
        <t> Finally, we let nil represent an empty octet string, i.e., len(nil) = 0.</t>

        <t> With prepend_len(octet_string) we denote the octet sequence that is obtained from prepending
            the length of the octet string as an utf-8 string to the byte sequence itself. (This will prepend one
            single octet for sequences shorter than 128 bytes and more octets otherwise). </t>
        <t> With prefix_free_cat(a0,a1, ...) we denote a function that outputs the prefix-free encoding of 
            all input octet strings as the concatenation of the individual strings with their respective 
            length prepended: prepend_len(a0) || prepend_len(a1) || ... . Use of this function allows for a 
            easy parsing of strings and guarantees a prefix-free encoding. 
        </t>

        <t> With sample_random_bytes(n) we denote a function that returns n octets uniformly sampled between 0 and 255.</t>
        <t> With zero_bytes(n) we denote a function that returns n octets with value 0.</t>
        
        <t> With ISK we denote the intermediate session key output string provided by CPace. It is RECOMMENDED to convert the
            intermediate session key ISK ot a final session key by using a suitable KDF function prior to using the key in a 
            higher-level protocol. </t>
      
        <t> With DSI we denote domain-separation identifier strings. </t> 
      </section>
      
      <section title="Protocol Flow" anchor="flow">
        <t>CPace is a one round protocol to establish an intermediate shared secret ISK 
          with implicit mutual authentication.
          In the setup phase both sides agree on a common hash function H and a group G.
          
          Prior to invocation, A and B are provisioned with public (CI) and secret
          information (PRS) as prerequisite for running the protocol. 
          During the first round, A sends a public share Ya 
          to B, and B responds with its own public share Yb. 
          Both A and B then derive a shared secret ISK. ISK is meant to be
          used for producing encryption and authentication keys by a KDF function
          outside of the scope of CPace.
 
          Optionally when starting the protocol, A and B dispose of a sid string.
          sid is typically pre-established by a higher-level protocol 
          invoking CPace. If no such sid is available from a higher-level
          protocol, a suitable approach is to let A choose a fresh random sid 
          string and send it to B together with the first message. This method is shown in the
          setup protocol section below. </t>

        <t>This sample trace is shown below.</t>
        <figure><artwork><![CDATA[
                A                  B
                | (setup protocol  |
  (sample sid)  |     and sid)     |
                |----------------->|
       ---------------------------------------
                |                  |
  (compute Ya)  |      Ya, ADa     |
                |----------------->|
                |      Yb, ADb     | (compute Yb)
                |<-----------------|
                |   (verify data)  |
                |   (derive ISK)   |

        ]]></artwork></figure>
      </section>

      <section title="CPace" anchor="cpace">
      <t> In the setup phase, both parties A,B agreed on the group G a hash H. If a higher-level protocol provided a session id sid, both parties SHALL use this value in the protocol execution. If there is a clear initiator (party A) and responder (party B) role assigned in the application setting, A SHOULD sample a fresh random value sid and transmit it together with its first message. If the application scenario does not enforce an ordering of the two messages and no sid value is available from a higher-level protocol, then the empty string shall be used for the session id. </t>
        <t> To begin, A calculates a generator g = G.calculate_generator(H, PRS,CI,sid). 
        </t> 
        <t> A samples ya = G.sample_scalar() randomly according to the requirements for group G.
            A then calculates Ya= G.scalar_mult (ya,g). A then transmits MSGa = prefix_free_cat(Ya, ADa) with 
            Ya and the optional associated data ADa to B. Note that prefixing the transmitted components with their
            respective lengths allows for unambigous parsing of MSGa by the receiver and guarantees a
            prefix-free encoding.</t>

        <t> B picks yb = G.sample_scalar() randomly. B then calculates 
            g = G.calculate_generator(H, PRS,CI,sid) and
            Yb = G.scalar_mult(yb,g). B then calculates K = G.scalar_mult_vfy(yb,Ya). 
            B MUST abort if K is the encoding of the neutral element G.I.
            Otherwise B sends MSGb = prefix_free_cat(Yb, ADb) to A and proceeds as follows.

            B returns ISK = H.hash(prefix_free_cat(G.DSI || "ISK", sid, K, CONCAT(MSGa, MSGb))).</t>

        <t> Upon reception of Yb, A calculates K = scalar_mult_vfy(Yb,ya). A MUST abort if K is the neutral element I.
            If K is different from I, A returns ISK = H.hash(prefix_free_cat(G.DSI || "ISK", sid, K, CONCAT(MSGa, MSGb))). </t>

        <t>Upon completion of this protocol, the session key ISK returned by A and B will be identical by both
           parties if and only if the supplied input parameters sid, PRS and CI match on both sides and the 
           transcripts match.</t>
           
        <t>In application scenarios which are guaranteed to enforce clear initiator and responder roles unordered concatenation SHOULD BE used for the CONCAT(MSGa,MSGb) function. In applications without enforced ordering of the transmission of MSGa and MSGb,
        CONCAT() MUST BE implemented by using the ordered concatenation function oCAT(). </t>
           
      </section>

    </section>
    <section title="Ciphersuites" anchor="Ciphersuites">
        <t>
            This section documents CPACE ciphersuite configurations. A ciphersuite
            is REQUIRED to specify, 
             <list style="symbols">
                   <t>a group G with associated definitions for G.sample_scalar(), G.scalar_mult() and G. scalar_mult.vfy() and G.calculate_generator() functions and an associated domain separation string G.DSI . </t>
                   <t> a hash function H </t> 
             </list>
            </t>
         <t>
            Currently, test vectors are available for the cipher suites
            CPACE-X25519-SHA512, 
            CPACE-X448-SHAKE256, 
            CPACE-P256-SHA256,
            CPACE-RISTR255-SHA512, 
            CPACE-DECAF448-SHAKE256. 
         </t>
    </section>

    <section title="Use of the hash function in CPace">
     <t>
         With generator_string(PRS,DSI,CI,sid, H.s_in_bytes) we denote a function that returns a string
         prefix_free_cat(PRS,zero_bytes(len_zpad), DSI, CI, sid) in which all input strings are concatenated
         such that the encoding of PRS together with a suitable zero pad field completely fills the first input block
         of the hash.
         
         The length len_zpad of the zero padding is calculated as len_zpad = MAX(0, H.s_in_bytes - len(prepend_length(PRS)) - 1).
     </t>
     
    </section>
     
    <section title="CPace on single-coordinate Ladders on Montgomery curves">
     <t>
      In this section we consider the case of CPace using the X25519 and X448 Diffie-Hellman functions 
      from <xref target="RFC7748"/> operating on the Montgomery curves Curve25519 and Curve448 <xref target="RFC7748"/>.
      
      CPace implementations using single-coordinate ladders on further Montgomery curves SHALL use the definitions in line
      with the specifications for X25519 and X448 and review the guidance given in the security consideration section and
      <xref target="cpace_paper" />.
      
      For X25519 the following definitions apply:
      <list style="symbols">
      <t> G.sample_scalar() = sample_random_bytes(32) </t>
      <t> G.scalar_mult(y,g) = G.scalar_mult_vfy(y,g) = X25519(y,g)</t> 
      <t> G.I = zero_bytes(32) </t>
      <t> G.DSI = "CPace255" </t>
      <t> G.field_size_bytes = 32 </t>
      <t> G.field_size_bits = 255 </t>
      </list>

      For X448 the following definitions apply:
      <list style="symbols">
      <t> G.sample_scalar() = sample_random_bytes(56) </t>
      <t> G.scalar_mult(y,g) = G.scalar_mult_vfy(y,g) = X448(y,g)</t> 
      <t> G.I = zero_bytes(56) </t>
      <t> G.DSI = "CPace448" </t>
      <t> G.field_size_bytes = 56 </t>
      <t> G.field_size_bits = 448 </t>
      </list>
                  
      The G.calculate_generator(H, PRS,sid,CI) function shall be implemented as follows.
      <list style="symbols">
      <t> First gen_str = generator_string(PRS,G.DSI,CI,sid, H.s_in_bytes) is calculated using the input block size of the 
          chosen hash primitive. </t>
      <t> This string is then hashed to the required length 
          gen_str_hash = H.hash(gen_str, G.field_size_bytes). 
          Note that this implies that the permissible output length H.maxb_in_bytes MUST BE larger or equal to the 
          field size of the group G for making a hashing primitive suitable.
      </t>
      <t> This result is then considered as a field coordinate using
          the u = decodeUCoordinate(gen_str_hash, G.field_size_bits) function from <xref target="RFC7748"/> which we
          repeat in the appendix for convenience.
       </t>
      <t> The result point g is then calculated as (g,v) = map_to_curve_elligator2(u) using the function 
          from <xref target="HASH2CURVE"/>. Note that the v coordinate produced by the map_to_curve_elligator2 function
          is not required for CPace and discarded.  
       </t>
     </list>
            
     In the appendix we show sage code that can be used as reference implementation for the calculate_generator and
         key generation functions.

        The definitions above aim at making the protocol suitable for outsourcing CPace to
        secure elements (SE) where nested hash function constructions such as defined in <xref target="RFC5869"/> 
        have to be considered to be particularly costly. Moreover as all hash operations are executed using strings
        with a prefix-free encoding also Merkle-Damgard constructions such as the SHA2 family can be considered as
        a representation of a random oracle, given that the permutation function is considered as a random oracle.
        
        Finally, with the introduction of a zero-padding after the PRS string, the CPace design aims at mitigating 
        attacks of a side-channel adversary that analyzes correlations between publicly known information with 
        the low-entropy PRS string.
     </t>
    </section>

    <section title="CPace on prime-order group abstractions.">
     <t>
      In this section we consider the case of CPace using the ristretto25519 and decafX448 group abstractions.
      These abstractions define an encode and decode function, group exponentiation
      and a one-way-map. 
           
      For ristretto255 the following definitions apply:
      <list style="symbols">
      <t> G.DSI = "CPaceRistretto" </t>
      <t> G.field_size_bytes = 32 </t>
      <t> G.group_size_bits = 252 </t>
      </list>

      For decaf448 the following definitions apply:
      <list style="symbols">
      <t> G.DSI = "CPaceDecaf" </t>
      <t> G.field_size_bytes = 56 </t>
      <t> G.group_size_bits = 488 </t>
      </list>

      For both abstractions the following definitions apply:
      <list style="symbols">
      <t> G.sample_scalar() = sample_random_bytes(G.group_size_bits) (Todo: add masking the upper bits!).</t>
      <t> G.scalar_mult(y,g) = encode(g^y)</t>
      <t> G.I = encode(g^0), where g is an arbitrary generator</t>
      <t> G.scalar_mult_vfy(y,X) is implemented as follows.
          if the decode(X) function fails, it returns G.I. Otherwise it returns encode( decode(X)^y )</t>
      </list>
      Note that with these definitions the scalar_mult function operates on a decoded point g and returns an encoded point,
      while the scalar_mult_vfy(y,X) function operates on a scalar and an encoded point X.

      The G.calculate_generator(H, PRS,sid,CI) function shall return a decoded point and be implemented as follows.
      <list style="symbols">
      <t> First gen_str = generator_string(PRS,G.DSI,CI,sid, H.s_in_bytes) is calculated using the input block size of the 
          chosen hash primitive. </t>
      <t> This string is then hashed to the required length 
          gen_str_hash = H.hash(gen_str, 2 * G.field_size_bytes). 
          Note that this implies that the permissible output length H.maxb_in_bytes MUST BE larger or equal to twice the 
          field size of the group G for making a hashing primitive suitable.
      </t>
      <t>
          Finally the generator g is calculated as g = one_way_map(gen_str_hash) using the one-way map function
          from the abstraction.
      </t>
      </list>
    
     </t>
    </section>

    <section title="CPace on curves in Short-Weierstrass representation.">

     <t>      
      This cipher suite targets applications that operate on prime-order 
      elliptic curves represented in Short-Weierstrass representation
      as for instance NIST-P256. Here we aimed at reusing existing encoding and curve standards wherever possible. 
      For the procedures in this section any suitable group MUST BE of prime order.</t>
 
     <t>      
      In this case, any elliptic curve group is characterized by
      <list style="symbols">
      <t> An integer constant G.group_order which MUST BE a prime. </t>
      <t> A string G.DSI which shall be defined by the canonical curve name from <xref target="IEEE1363"/> </t>
      <t> A G.is_in_group(X) function which returns true if the input X is a valid encoding according to 
          <xref target="IEEE1363"/> of a point on the group. </t>
      <t> G.I is an encoding of the x-coordinate according to <xref target="IEEE1363"/> of the neutral element on the curve. </t>
      <t> G.encode_to_curve(str) is the function defined in <xref target="HASH2CURVE"/> using the SSWU map. </t>
      </list>

      Here the following definition of the CPace functions applies.
      <list style="symbols">
      <t> Here G.sample_scalar() is a function that samples a value between 1 and (G.group_order - 1) 
          which MUST BE uniformly random. </t>
      <t> G.scalar_mult(s,X) operates on a scalar s and an input point X encoded in full coordinates according to <xref target="IEEE1363"/>. It also returns a full-coordinate output (i.e. both, x and y coordinates). </t>
      <t> G.scalar_mult_vfy(s,X) operates on a scalar s and a full-coordinate point X. It is implemented as follows.
          if G.is_in_group(X) is false, it returns G.I . Otherwise it returns the x-coordinate of X^s</t>
      </list>
      
      The G.calculate_generator(H, PRS,sid,CI) function shall be implemented as follows.
      <list style="symbols">
      <t> First gen_str = generator_string(PRS,G.DSI,CI,sid, H.s_in_bytes) is calculated using the input block size of the 
          chosen hash primitive. </t>
      <t> Then the output of a call to G.encode_to_curve(gen_str) is returned.
      </t>
      </list>

     </t>      
    </section>

    
    <section title="Security Considerations">
      <t>A security proof of CPace is found in <xref target="cpace_paper"/>.  </t>

        <t>In order to prevent length-extension attacks, all hash inputs MUST be prefix-free strings in order to 
           make CPace suitable when Merkle-Damgard hashing constructions such as SHA2 or SHA512
           are considered <xref target= "CDMP05"/>. Otherwise so-called length-extension attacks of the hash
           would have to be considered. This is guaranteed by the design of the prefix_free_cat() function. </t>

        <t>Although already K is a shared value, still it MUST NOT be used as a shared secret key.
          Note that calculation of ISK from K includes the protocol transcript and
          prevents key malleability with respect to man-in-the-middle attacks from active adversaries.</t>

<t>   The definitions given for the case of Curve25519 and Curve448 rely on the following properties of the
      elliptic curves <xref target="cpace_paper" />:  
      <list style="symbols">
      <t> The curve has order (p * c) with p prime and c a small cofactor. Also the curve's quadratic twist must be of 
          order (p' * c') with p' prime and c' a cofactor.</t>
      <t> The cofactor c' of the twist MUST BE EQUAL to or an integer multiple of the cofactor c of the curve.</t>
      <t> The representation of the neutral element G.I MUST BE the same for both, the curve and its twist.</t>
      <t> Both field order q and group order p are close to a power of two such that randomly sampled binary strings
          can be used as representation for field elements and scalars <xref target="cpace_paper" /> .</t>
      </list>
      
 </t>
 
       <t>Elements received from a peer MUST be checked by a proper implementation of the scalar_mult_vfy methods. 
          Failure to properly validate group elements can lead to attacks. The Curve25519-based cipher suite employs
          the twist security feature of the curve for point validation. 
          As such, it is mandatory to check that any actual X25519 function implementation maps 
          all low-order points on both the curve and the twist on the neutral element.
          Corresponding test vectors are provided in the appendix.</t>

      <t>The randomly generated values ya and yb MUST NOT be reused.</t>

      <t>CPace is not originally meant to be used in conjunction with servers supporting several users and, thus
         several different username/password pairs. 
         In this setting it is RECOMMENDED to consider the augmented PAKE protocol OPAQUE or 
         to use CPace as building block of the augmented AuCPace protocol  
         <xref target="aucpace_paper"/>.</t>

      <t>If CPace is used as a building block of higher-level protocols, it is RECOMMENDED that sid
         is generated by the higher-level protocol and passed to CPace. One suitable option is that sid 
         is generated by concatenating ephemeral random strings from both parties. </t>

      <t>Since CPace is designed to be used as a building block in higher-level protocols and for 
         compatibility with constrained hardware, 
         it does not by itself include a strong key derivation function construction. 
         Instead CPace uses a simple hash operation on a prefix-free string input for generating its 
         intermediate key ISK.
         It is RECOMMENDED that the ISK is post-processed by a KDF such as <xref target="RFC5869" />
         according the needs of the higher-level protocol. In case
         that the CPace protocol is delegated to a secure element hardware, it is RECOMMENDED that the calculation of 
         the KDF function is implemented in the main processing unit.
      </t>

      <t>In case that side-channel attacks are to be considered practical for a given application, it is RECOMMENDED to focus
         side-channel protections such as masking and redundant execution (faults) on the process of calculating
         the secret generator G.calculate_generator(PRS,CI,sid). 
         The most critical aspect to consider is the processing of the first block of the hash that includes 
         the PRS string. The CPace protocol construction considers the fact that side-channel protections of hash functions might 
         be particularly resource hungry. For this reason, CPace aims at minimizing the number 
         of hash functions invocations in the 
         specified calculate_generator function.</t>

      <t>CPace is proven secure under the hardness of the computational Simultaneous Diffie-Hellmann (SDH) 
         assumption in the group G (as defined in <xref target="cpace_paper"/>). 
         Still, even for the event that large-scale quantum computers (LSQC) will become available, CPace forces an active 
         adversary to solve one CDH per password guess <xref target="cpace_eaton_stebila"/>. 
         In this sense, using the wording suggested by Steve Thomas on the CFRG mailing list,
         CPace is "quantum-annoying".
      </t>

      <t>While the zero-padding introduced when hashing the sensitive PRS string can be expected to make 
         the task for a side-channel
         adversary more complex, this feature allone is not sufficient for preventing power analysis attacks.
      </t>

    </section>
    <section title="IANA Considerations">
      <t>No IANA action is required.</t>
    </section>
    <section title="Acknowledgments">
      <t> Thanks
         to the members of the CFRG for
        comments and advice. Any comment and advice is appreciated. </t> 
       <t> Comments are specifically invited regarding
        the inclusion or exclusion of both, initiator/responder and symmetric settings.  
        Currently we plan to consider both application settings in this draft. </t>
    </section>
  </middle>
  <back>

    <references title="Normative References">
      <reference anchor="SEC1">
        <front>
          <title>STANDARDS FOR EFFICIENT CRYPTOGRAPHY, "SEC 1: Elliptic Curve
            Cryptography", version 2.0</title>
          <author>
            <organization>SEC</organization>
          </author>
          <date month="May" year="2009" />
        </front>
        <format type="PDF" target="http://www.sec.org/sec1-v2.pdf" />
      </reference>
<!--      &RFC2104; HMAC -->
      &RFC2119;
<!--      &RFC4493; AES CMAC -->
      &RFC5480;
      &RFC5869;
      &RFC6234;
      &RFC7748;
<!--      &RFC7914; -->
      &RFC8032;
      &RFC8174;
 
      <reference anchor="HASH2CURVE">
        <front>
          <title> draft-irtf-cfrg-hash-to-curve-05 </title>
          <author initials="A." surname="Faz-Hernandez" />
          <author initials="S." surname="Scott" />
          <author initials="N." surname="Sullivan" />
          <author initials="R." surname="Wahby" />
          <author initials="C." surname="Wood" />
          <date year="2019" />
        </front>
        <annotation>IRTF draft standard
        </annotation>
      </reference>
              
      <reference anchor="CDMP05" target="https://doi.org/10.1007/11535218_26">
          <front>
            <title>Merkle-Damgaard Revisited: How to Construct a Hash Function</title>
            <seriesInfo name="DOI" value="10.1007/11535218_26"/>
            <seriesInfo name="pages" value="430-448"/>
            <seriesInfo name="In" value="Advances in Cryptology - CRYPTO 2005"/>
            <author initials="J-S." surname="Coron" fullname="Jean-Sebastien Coron">
              <organization>University of Luxembourg</organization>
            </author>
            <author initials="Y." surname="Dodis" fullname="Yevgeniy Dodis">
              <organization>New York University</organization>
            </author>
            <author initials="C." surname="Malinaud" fullname="Cecile Malinaud">
              <organization>University of Luxembourg</organization>
            </author>
            <author initials="P." surname="Puniya" fullname="Prashant Puniya">
              <organization>New York University</organization>
            </author>
            <date year="2005"/>
          </front>
        </reference>

      <reference anchor="SHA3">
        <front>
          <title>"SHA-3 Standard: Permutation-Based Hash and Extendable-
              Output Functions", FIPS PUB 202</title>
         <author initials="NIST" surname="National Institute of Standards and Technology (NIST)" />
           <date year="2015" />
        </front>
        <annotation>https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf
        </annotation>
      </reference>

      <reference anchor="IEEE1363">
        <front>
          <title>"Standard Specifications for Public Key Cryptography", IEEE 1363</title>
         <author initials="" surname="IEEE" />
           <date year="2000" />
        </front>
        <annotation>IEEE 1363
        </annotation>
      </reference>

    </references>
    <references title="Informative References">
      <reference anchor="cpace_paper">
        <front>
          <title>Security analysis of CPace.</title>
          <author initials="M." surname="Abdalla" />
          <author initials="B." surname="Haase" />
          <author initials="J." surname="Hesse" />
          <date month="January" year="2021" />
        </front>
        <annotation>eprint.iacr.org/2021/114
        </annotation>
      </reference>

      <reference anchor="cpace_eaton_stebila">
        <front>
          <title>The "quantum annoying" property of password-authenticated key exchange protocols.</title>
          <author initials="E." surname="Eaton" />
          <author initials="D." surname="Stebila" />
          <date month="May" year="2021" />
        </front>
        <annotation>https://eprint.iacr.org/2021/696
        </annotation>
      </reference>

      <reference anchor="aucpace_paper">
        <front>
          <title>AuCPace. PAKE protocol tailored for the use in the internet of things.</title>
          <author initials="B." surname="Haase" />
          <author initials="B." surname="Labrique" />
          <date month="Feb" year="2018" />
        </front>
        <annotation>eprint.iacr.org/2018/286
        </annotation>
      </reference>

<!--
      <reference anchor="IsogenyPAKE">
        <front>
          <title>An Isogeny-Based Password-Authenticated Key Establishment Protocol.</title>
          <author initials="O." surname="Taraskin" />
          <author initials="V." surname="Soukharev" />
          <author initials="D." surname="Jao" />
          <author initials="J." surname="LeGrow" />
          <date month="Sep." year="2018" />
        </front>
        <annotation>eprint.iacr.org/2018/886
        </annotation>
      </reference>
-->


      <reference anchor="VTBPEKE">
        <front>
          <title> 
             VTBPEKE: Verifier-based Two-Basis Password ExponentialKey Exchange
          </title>
          <author initials="D." surname="Pointcheval" />
          <author initials="G." surname="Wang" />
          <date year="2017" />
        </front>
        <annotation>Proceedings of the 2017 {ACM} on Asia Conference on Computer and Communications
               Security, AsiaCCS 2017
        </annotation>
      </reference>

<!--
      <reference anchor="TDH">
        <front>
          <title>The Twin-Diffie Hellman Problem and Applications</title>
          <author initials="D." surname="Cash" />
          <author initials="E." surname="Kiltz" />
          <author initials="V." surname="Shoup" />
          <date year="2008" />
        </front>
        <annotation>EUROCRYPT 2008.  Volume 4965 of Lecture notes in Computer
          Science, pages 127-145.  Springer-Verlag, Berlin, Germany.
        </annotation>
      </reference> -->

<!--      &RFC8265; Einheitliche Usernamen und Strings für Passworte -->
    </references>

<!--
    <section anchor="pointgen" title="Algorithm used for Point Generation">
      <t>This section describes the algorithm that was used to generate
      the points (M) and (N) in the table in <xref target="Ciphersuites"/>.</t>


      <t>The following python snippet generates the above points,
      assuming an elliptic curve implementation following the
      interface of Edwards25519Point.stdbase() and
      Edwards448Point.stdbase() in Appendix A of <xref target="RFC8032" />:</t>

      <figure><artwork><![CDATA[
def iterated_hash(seed, n):
    h = seed
    for i in range(n):
        h = hashlib.sha256(h).digest()
    return h

def bighash(seed, start, sz):
    n = -(-sz // 32)
    hashes = [iterated_hash(seed, i) for i in range(start, start + n)]
    return b''.join(hashes)[:sz]

def canon_pointstr(ecname, s):
    if ecname == 'edwards25519':
        return s
    elif ecname == 'edwards448':
        return s[:-1] + bytes([s[-1] & 0x80])
    else:
        return bytes([(s[0] & 1) | 2]) + s[1:]

def gen_point(seed, ecname, ec):
    for i in range(1, 1000):
        hval = bighash(seed, i, len(ec.encode()))
        pointstr = canon_pointstr(ecname, hval)
        try:
            p = ec.decode(pointstr)
            if p != ec.zero_elem() and p * p.l() == ec.zero_elem():
                return pointstr, i
        except Exception:
            pass
]]></artwork></figure>
    </section>

    <section anchor="testvectors" title="Test Vectors">
      <t>This section contains test vectors for CPace using 
        the X25519-ELLIGATOR2_SHA512-SHA512 and P-256-SHA256-HKDF_SHA256 ciphersuites. 
        All points are 
        encoded using the compressed format, while the y coordinate information is not used
        for deriving the session key. 

        prefix, specified in <xref target="SEC1"/> A and B identity strings
        are provided in the protocol invocation.
      </t>
-->

     <section title="CPace25519 Test Vectors">
       <t>  The test vectors for CPace25519 consist of three blocks. </t>
       <t> First test vectors for X25519 are provided which is used as
          combined scalar multiplication, cofactor clearing and verification
          function. Specifically, test vectors for the small order points
          are provided for checking that all small order points are mapped to
          the neutral element  </t>

       <t> Then test vectors for the Elligator2 primitive are provided. </t> 
       <t> Then test vectors for the encoding of the secret generator are provided combining
          the hash operation and the encoding of the generator. </t>
       <t>
          Finally test vectors for a honest party protocol execution are provided, including
          derivation of the session key ISK.
       </t> 
     <section title="X25519 test vectors">

        <figure><artwork><![CDATA[
########################### /X25519 ###############################
Test vectors for X25519 include three values:
- The scalar encoding prior to co-factor clearing and clamping, s
- The little-endian byte string encoding of the input point, u
- The expected little-endian byte string encoding of the result, r

The test vectors below shall be applied to the X25519 function 
called with the outputs of the decode-u-coordinate function
(that is expected to clear the most significant bit.

Test vector for X25519 with a coordinate on J:
s: a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4
u: e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c
r: c3da55379de9c6908e94ea4df28d084f32eccf03491c71f754b4075577a28552

Test vector for X25519 with a coordinate on the twist J':
s: 4b66e9d4d1b4673c5ad22691957d6af5c11b6421e0ea01d42ca4169e7918ba0d
u: e5210f12786811d3f4b7959d0538ae2c31dbe7106fc03c3efc4cd549c715a413
r: 95cbde9476e8907d7aade45cb4b873f88b595a68799fa152e6f8f7647aac7957

Out in the wild there might be two variants of X25519 which
differ by clearing or not clearing bit #255 of inputs.

Test vectors for plain X25519 that MUST return the neutral element 
for X25519 implementations that don't clear bit #255 of inputs.
u0: 0000000000000000000000000000000000000000000000000000000000000000
u1: 0100000000000000000000000000000000000000000000000000000000000000
u2: e0eb7a7c3b41b8ae1656e3faf19fc46ada098deb9c32b1fd866205165f49b800
u3: 5f9c95bca3508c24b1d0b1559c83ef5b04445cc4581c8e86d8224eddd09f1157
u4: ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f
u5: edffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f
u6: eeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f
u7: cdeb7a7c3b41b8ae1656e3faf19fc46ada098deb9c32b1fd866205165f49b880
u8: 4c9c95bca3508c24b1d0b1559c83ef5b04445cc4581c8e86d8224eddd09f11d7
u9: d9ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ua: daffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ub: dbffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

Results for X25519 implementations *not* clearing bit #255:
s = af46e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449aff
rN = X25519(uX, s);
r0: 0000000000000000000000000000000000000000000000000000000000000000
r1: 0000000000000000000000000000000000000000000000000000000000000000
r2: 0000000000000000000000000000000000000000000000000000000000000000
r3: 0000000000000000000000000000000000000000000000000000000000000000
r4: 0000000000000000000000000000000000000000000000000000000000000000
r5: 0000000000000000000000000000000000000000000000000000000000000000
r6: 0000000000000000000000000000000000000000000000000000000000000000
r7: 0000000000000000000000000000000000000000000000000000000000000000
r8: 0000000000000000000000000000000000000000000000000000000000000000
r9: 0000000000000000000000000000000000000000000000000000000000000000
ra: 0000000000000000000000000000000000000000000000000000000000000000
rb: 0000000000000000000000000000000000000000000000000000000000000000

Results for X25519 implementations that *do* clear bit #255:
s = af46e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449aff
qN = X25519(uX & ((1 << 255) - 1),s);
q0: 0000000000000000000000000000000000000000000000000000000000000000
q1: 0000000000000000000000000000000000000000000000000000000000000000
q2: 0000000000000000000000000000000000000000000000000000000000000000
q3: 0000000000000000000000000000000000000000000000000000000000000000
q4: 0000000000000000000000000000000000000000000000000000000000000000
q5: 0000000000000000000000000000000000000000000000000000000000000000
q6: 0000000000000000000000000000000000000000000000000000000000000000
q7: e062dcd5376d58297be2618c7498f55baa07d7e03184e8aada20bca28888bf7a
q8: 993c6ad11c4c29da9a56f7691fd0ff8d732e49de6250b6c2e80003ff4629a175
q9: db64dafa9b8fdd136914e61461935fe92aa372cb056314e1231bc4ec12417456
qa: d8e2c776bbacd510d09fd9278b7edcd25fc5ae9adfba3b6e040e8d3b71b21806
qb: c85c655ebe8be44ba9c0ffde69f2fe10194458d137f09bbff725ce58803cdb38

########################### X25519/ ###############################

    ]]></artwork></figure> 

     </section>  
     <section title="Elligator2 test vectors">
     <t> Two test vectors are provided </t>

        <figure><artwork><![CDATA[

#################### /Elligator 2 ##################################

Vector set 1 as little endian byte strings: 
in: bc149a46d293b0aeea34581349d72f8a5a96cd531102d67379cd9bfadd4ec800
out:66b68f7575cd282403fc2bd323ff04601203c1ec5516ce247f7c0adbef05d367

Vector set 1 as base 10 numbers:
in:  35391373371110637358764021258915994089392966
     2186061014226937583985831318716
out: 46961069109971370193035504450677895166687682
     601074157241352710439876254742118

####################################################################

Vector set 2 as little endian byte strings: 
in: 89cf55d4b5d3f84b1634957ac503a32b84ba11471a96b227bca70a0c3bf26375
out:1db163c86ceca7621903c9412d6dc71b4ed263b687eed092b194b5e540bba308

Vector set 2 as base 10 numbers:

in:  530971929581761349677698694411105058011053992421528586742712709
     85522606362505
out: 390779123641965710057372702362153599533842156764537839663973068
     2305857171741

#################### Elligator 2/ ##################################

    ]]></artwork></figure> 

     </section>  
     <section title="Test vectors for the secret generator G">  

        <figure><artwork><![CDATA[
###################### /Secret generator G #########################
Inputs:
DSI1 = 'CPace25519-1'
sid  = SHA512('sid'), bytes 0 to 15

Input strings without prepended length:
pw   = 'password'
A    = 'Ainitiator'
B    = 'Bresponder'
AD   = 'AD'
####################################################################
Outputs and intermediate results:

DSI11= 435061636532353531392d31 string (b'CPace25519-1') of len(12)
PRS  = 0870617373776f7264 (b'\x08password') string of len(9)
ZPAD = 107 zero bytes (before mixing in adversary controlled var. data)
sid  = 7e4b4791d6a8ef019b936c79fb7f2c57 string of len(16)
CI   = 0a41696e69746961746f720a42726573706f6e646572024144
       (b'\nAinitiator\nBresponder\x02AD') string of len(25)

u = SHA512(DSI1||PRS||ZPAD||sid||CI) as 512 bit little-endian int:
  0xc2d3f2db868b7cde013b1b7d3b27c9cdf6845ec2eaf18ec6bffcf70f40e73349
  << 256
+  0x491041def788da930a86b7dbfedbe016200c259d2d2a980dfde2238a3ea0a6c8
u as reduced base field element coordinate:
  0x34864e74f03d6387394ccc72c6c3d4a8b7b2368c0d05c98e7d6ecfcde0f247ec
Elligator2 output G as base field element coordinate:
  0xf0fdadcc2e334ceb73832be22e736a2a296dd46438f0541c1447dfbaf85ce1d 
  
###################### Secret generator G/ #########################
    ]]></artwork></figure> 

     </section>  
     <section title="Test vectors for CPace DH">  

        <figure><artwork><![CDATA[
##################### /CPace Diffie-Hellman ########################
Inputs: 

Elligator2 output G as base field element coordinate:
  0x307760941be97d7c68b037cb9d22d69838b60e194c50ded8b85873f9e1395126
Elligator2 output G encoded as little endian byte string:
    265139e1f97358b8d8de504c190eb63898d6229dcb37b0687c7de91b94607730

Secret scalar ya=SHA512('ya'), bytes 0...31, as integer:
  0xbfec93334144994275a3eba9eb0adf3fe40d54e400d105d59724bee398b722d1
ya encoded as little endian byte string:
    d122b798e3be2497d505d100e4540de43fdf0aeba9eba375429944413393ecbf

Secret scalar yb=SHA512('yb'), bytes 0...31, as integer:
  0xb16a6ff3fcaf874cb59058493cb1f28b3e20084ad6d46fcd3c053284d60cecc0
yb encoded as little endian byte string:
    c0ec0cd68432053ccd6fd4d64a08203e8bf2b13c495890b54c87affcf36f6ab1

####################################################################
Outputs:

Public point Ya as integer:
  0x79f9f2c1245fd8c4ab38bc75082f2daf6f47ca53fd5f0de7af72fee9c7ddd993
Ya encoded as little endian byte string:
    93d9ddc7e9fe72afe70d5ffd53ca476faf2d2f0875bc38abc4d85f24c1f2f979

Public point Yb as integer:
  0x18ac9063b4419695db48028d2eda7b2b2e649d22f56a5987eba9f05941de1c74
Yb encoded as little endian byte string:
    741cde4159f0a9eb87596af5229d642e2b7bda2e8d0248db959641b46390ac18

DH point K as integer:
  0x276896a227a09f389a04b9656099aa05ef8ec2b394cf32cc50cca9ae56334215
K encoded as little endian byte string:
    15423356aea9cc50cc32cf94b3c28eef05aa996065b9049a389fa027a2966827

##################### CPace Diffie-Hellman/ ########################

    ]]></artwork></figure> 

     </section>  
     <section title="Test vectors for intermediate session key generation">  

        <figure><artwork><![CDATA[
#################### /Session Key derivation #######################
Inputs:

DSI2 = 435061636532353531392d32 string ('CPace25519-2') of len(12)
sid  = 7e4b4791d6a8ef019b936c79fb7f2c57 string of len(16)

strings of length 32:
K = 15423356aea9cc50cc32cf94b3c28eef05aa996065b9049a389fa027a2966827
Ya= 93d9ddc7e9fe72afe70d5ffd53ca476faf2d2f0875bc38abc4d85f24c1f2f979
Yb= 741cde4159f0a9eb87596af5229d642e2b7bda2e8d0248db959641b46390ac18

####################################################################

string of length 64:
ISK = SHA512(DSI2 || sid || K || Ya || Yb)
  = de0be1eeb7e6453d8c961353cd333694866f5432f24b0d4ed393cb6473e835df
    265ce72613effa3368a907031d897c733d300dfdb364ff66d270b404cdfbcb0a
    
#################### Session Key derivation/ #######################
    ]]></artwork></figure> 

     </section>  
     </section>  

  </back>
</rfc>
